<!DOCTYPE html>
<html lang="">

<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer">


<base href="https://netcookies.github.io/b/">
<title>


     当梯子不可用时可以自动重启梯子的脚本 

</title>
<link rel="canonical" href="https://netcookies.github.io/b/post/2016-09-15/">


<script type="text/javascript">
    var baseURL = 'https:\/\/netcookies.github.io\/b\/';
    var host = baseURL.substring(0, baseURL.length - 1).replace(/\//g, '');
    if ((host === window.location.host) && (window.location.protocol !== 'https:')) {
        window.location.protocol = 'https:';
    }
</script>





<link rel="stylesheet" href="/css/reset.css">
<link rel="stylesheet" href="/css/pygments.css">
<link rel="stylesheet" href="/css/main.css">




<link rel="shortcut icon"

    href="/img/favicon.ico"

>






</head>


<body lang="">

<section class="header"> 
    <div class="container">
        <div class="content">
            
            <a href="/"><div class="name"></div></a>
            <nav>
                <ul>
                    <a href="/blog/"><li>Blog</li></a>
                    <a href="/about/"><li>About</li></a>
                    <a href="/code/"><li>Code</li></a>
                </ul>
            </nav>
        </div>
    </div>
</section>

<section class="icons">
    <div class="container">
        <div class="content">

        
        
        

        

        

        

        

        
            <a href="https://netcookies.github.io/b/index.xml">
                <i class="icon ion-social-rss larger"></i>
            </a>
        
        </div>
    </div>
</section>

<section class="main">
    <div class="container">
        <div class="content">
            

<h3 id="序">序</h3>

<p>总有各种各样的原因会使梯子无法使用，此时往往重启服务是最快的选择。
然而并不是时刻你都有电脑在边上，手机打开 ssh,telnet 也并不方便。
“这就尴尬了。”
于是我便写下了这个脚本。适用各种支持 socks5、http 梯子。
以下都以 debian 系的 linux 例，centos 系请自行更改包管理和 daemon 管理的命令。</p>

<hr />

<p>###服务端配置
* 安装必要组件</p>

<pre><code class="language-bash">apt-get install -y lighttpd php5-cgi 
lighttpd-enable-mod auth
lighttpd-enable-mod fastcgi
lighttpd-enable-mod fastcgi-php
</code></pre>

<ul>
<li>配置 lighttpd
1.配置 http basic 认证，用于保护 site，先保存下面的脚本为 <code>auth.sh</code></li>
</ul>

<pre><code class="language-bash">#!/bin/sh
user=$1
realm=$2
pass=$3
hash=`echo -n &quot;$user:$realm:$pass&quot; | md5sum | cut -b -32`
echo &quot;$user:$realm:$hash&quot; &gt; /etc/lighttpd/lighttpd.user
cat&gt;/etc/lighttpd/conf-enabled/05-auth.conf&lt;&lt;EOF
server.modules                += ( &quot;mod_auth&quot; )

auth.backend                 = &quot;htdigest&quot;
auth.backend.htdigest.userfile = &quot;/etc/lighttpd/lighttpd.user&quot;
auth.require = ( &quot;/proxy&quot; =&gt;
(
	&quot;method&quot; =&gt; &quot;basic&quot;,
	&quot;realm&quot; =&gt; &quot;proxy&quot;,
	&quot;require&quot; =&gt; &quot;user=$user&quot;
)
)
EOF
</code></pre>

<p>2.运行 auth.sh，三个参数分别为用户名、域、密码</p>

<pre><code class="language-bash">sh auth.sh &lt;user&gt; &lt;realm&gt; &lt;password&gt;
</code></pre>

<p>3.实现简易的 web 接口用来接收 client 端的 POST 请求</p>

<pre><code class="language-bash">#!/bin/sh
mkdir -p /var/www/proxy
cd /var/www/proxy
echo 0 &gt; restart.status
cat&gt;/var/www/ifproxyworking.php&lt;&lt;EOF
&lt;?php
$restart = $_POST['restart'];
$filename = &quot;restart.status&quot;;
if (isset($restart) &amp;&amp; is_numeric($restart) &amp;&amp; $restart &gt;= 0) {
	if ($restart != 0 &amp;&amp; $restart != 1) {
		$restart = 0;
	}
	$fh = fopen($filename, &quot;w&quot;);
	fwrite($fh, $restart, 1);
	fclose($fh);
}
?&gt;
EOF
chown -R www-data:www-data /var/www/proxy
/etc/init.d/lighttpd force-reload
</code></pre>

<ul>
<li>配置 crontab 及监控 daemon 的脚本
1.保存以下脚本<code>monitor.sh</code> proc_name 填你梯子 daemon 的名称，如 shadowsocks, v2ray etc
<code>bash
#!/bin/sh
proc_name=&quot;YOUR PROXY NAME&quot;
require_restart=`cat /var/www/proxy/restart.status`
if [ $require_restart -eq 1 ]; then
	/usr/sbin/service $proc_name restart
	echo 0 &gt; /var/www/proxy/restart.status
	exit 0
fi
number=`ps -ef | grep $proc_name | grep -v grep | wc -l`
if [ $number -eq 2 ]; then
	/usr/sbin/service $proc_name stop
	ps -ef | grep $proc_name | grep -v grep | awk '{print $2}' | xargs kill -9
	sleep 1
	/usr/sbin/service $proc_name start
fi
if [ $number -eq 0 ]; then
	/usr/sbin/service $proc_name start
fi
</code>
2.将脚本加入 crontab, 由于需重启 daemon，请使用 root 的 crontab
```bash
crontab -e
在最后一行加入， 注意将路径替换成你脚本保存的路径</li>
<li>* * * * /YOUR PATH/monitor.sh &gt;/dev/null 2&gt;&amp;1
```</li>
</ul>

<hr />

<p>###客户端配置
* 保存以下脚本<code>proxy_monitor.sh</code>
其中的 vpsip 直接填服务端的 ip 或替换脚本中的 <code>YOUR DOMAIN</code> 为服务端的域名
testip 中 curl 后的<code>socks5://127.0.0.1:1080</code>为 proxy 的地址，请自行替换
将 <code>YOUR PROXY DAEMON NAME</code> 改成客户端的 Daemon 名字</p>

<pre><code class="language-BASH">#!/bin/bash

vpsip=`nslookup YOUR DOMAIN | awk '/^Address: / { print $2 }'`
testip=`curl -sx socks5://127.0.0.1:1080 http://icanhazip.com -m 2`
rs=$?

if [[ $rs -eq 0 ]] &amp;&amp; [[ ${testip} = ${vpsip} ]]; then
	exit 0
elif [[ $rs -eq 28 ]]; then
	echo `date +%X` 'Proxy stucked, restarting'
	curl --user YOURUSERNAME:YOURPASSWORD --data &quot;restart=1&quot; http://YOURDOMAIN.COM/proxy/ifproxyworking.php
	/usr/sbin/service YOUR PROXY DAEMON NAME restart
elif [[ $rs -eq 7 ]]; then
	echo `date +%X` 'Proxy not running'
fi

exit $rs
</code></pre>

<ul>
<li>将脚本加入 crontab, 由于需重启 daemon，请使用 root 的 crontab</li>
</ul>

<pre><code class="language-bash">crontab -e
在最后一行加入， 注意将路径替换成你脚本保存的路径
* * * * * /YOUR PATH/proxy_monitor.sh &gt;/dev/null 2&gt;&amp;1
</code></pre>

        </div>
    </div>
</section>






</body>
</html>

